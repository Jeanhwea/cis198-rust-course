#+TITLE: CIS198 Lecture 2: ç»“æ„åŒ–çš„æ•°æ®
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2024-03-27 Wed>
#+STARTUP: overview num indent
#+OPTIONS: ^:nil

* ç»“æ„ä½“
** å®šä¹‰
#+BEGIN_SRC rust :exports both
  #[derive(Debug)]
  struct Point {
      x: i32,
      y: i32,
  }

  let mut origin = Point{x: 0, y: 0};
  println!("{:?}", origin);

  origin.x += 1;
  origin.y -= 1;
  println!("{:?}", origin);
#+END_SRC

#+RESULTS:
: Point { x: 0, y: 0 }
: Point { x: 1, y: -1 }

** è®¿é—®æ„ä½“å­—æ®µ
#+BEGIN_SRC rust :exports both
  #[derive(Debug)]
  struct Point {
      x: i32,
      mut y: i32,  // éæ³•çš„
  }

  let mut p = Point{x: 0, y: 0};
  println!("{:?}", p);

  p.x += 1;
  p.y -= 1;
  println!("{:?}", p);
#+END_SRC

#+RESULTS:
: error: Could not compile `cargoJ5EtMu`.

** mut ä¸æ˜¯ç»“æ„ä½“å±æ€§
#+BEGIN_SRC rust :exports both
  #[derive(Debug)]
  struct Point {
      x: i32,
      mut y: i32,  // éæ³•çš„
  }
#+END_SRC

#+RESULTS:
: error: Could not compile `cargoJ5EtMu`.

#+BEGIN_EXAMPLE
  error: expected identifier, found keyword `mut`
   --> src/main.rs:6:5
    |
  4 | struct Point {
    |        ----- while parsing this struct
  5 |     x: i32,
  6 |     mut y: i32,  // éæ³•çš„
    |     ^^^ expected identifier, found keyword

  error: could not compile `cargoJ5EtMu` (bin "cargoJ5EtMu") due to 1 previous error
#+END_EXAMPLE
** ç»“æ„ä½“çš„å‘½åç©ºé—´
#+BEGIN_SRC rust :exports both
  mod foo {
      #[derive(Debug)]
      pub struct Point {
          x: i32,
          y: i32,
      }

      pub fn new(x: i32, y: i32) -> Point {
          Point{x: x, y: y}
      }
  }

  fn main() {
      let p1 = foo::new(1, 2);
      println!("{:?}", p1);

      match p1 {
          foo::Point{x, y} => println!("{x}, {y}"),
      }
  }
#+END_SRC

#+RESULTS:
: error: Could not compile `cargoVwohr3`.

** ç»“æ„ä½“çš„ match
#+BEGIN_SRC rust :exports both
  #[derive(Debug)]
  pub struct Point {
      x: i32,
      y: i32,
  }

  fn main() {
      let p1 = Point{x:1, y:2};
      match p1 {
          Point{x, y} => println!("aa: {x}, {y}"),
      }

      match p1 {
          Point{x: x1, y: y1} => println!("bb: {x1}, {y1}"),
      }

      match p1 {
          Point{y, ..} => println!("cc: y={y}"),
      }
  }
#+END_SRC

#+RESULTS:
: aa: 1, 2
: bb: 1, 2
: cc: y=2

** ç»“æ„ä½“çš„æ›´æ–°
#+BEGIN_SRC rust :exports both
  #[derive(Debug)]
  pub struct Foo {
      a: i32,
      b: i32,
      c: i32,
      d: i32,
      e: i32,
  }

  fn main() {
      let p1 = Foo{a:1, b:1, c:2, d:2, e:2};
      println!("{:?}", p1);

      let p2 = Foo{e:999, ..p1};
      println!("{:?}", p2);

      // let p3 = Foo{..p1, e:666}; // æŠ¥é”™
      // println!("{:?}", p3);

      let p4 = Foo{a:11, b:22, c:33, ..p1};
      println!("{:?}", p4);
  }
#+END_SRC

#+RESULTS:
: Foo { a: 1, b: 1, c: 2, d: 2, e: 2 }
: Foo { a: 1, b: 1, c: 2, d: 2, e: 999 }
: Foo { a: 11, b: 22, c: 33, d: 2, e: 2 }

** Tuple Struct
#+BEGIN_SRC rust :exports both
  #[derive(Debug)]
  struct Color(i32, i32, i32);

  let mut c1 = Color(0, 255, 255);
  println!("{:?}", c1);

  c1.0 = 255;
  println!("{:?}", c1);

  match c1 {
      Color(r, g, b) => println!("r=0x{r:x}, g=0x{g:x}, b=0x{b:x}"),
  }
#+END_SRC

#+RESULTS:
: Color(0, 255, 255)
: Color(255, 255, 255)
: r=0xff, g=0xff, b=0xff

** Tuple Struct vs Type Alias
#+BEGIN_SRC rust :exports both
  #[derive(Debug, PartialEq)]
  struct Meters(i32);
  #[derive(Debug)]
  struct Yards(i32);

  // support `==' or `+'
  type MetersAlias = i32;
  type YardsAlias = i32;

  let a1 = Meters(0);
  let c1 = Meters(0);
  let b1 = Yards(1);
  // println!("{:?}", a1 + c1);
  // println!("{:?}", a1 == b1);


  let a2 : MetersAlias=0;
  let a3 : MetersAlias=1;
  let b2 : YardsAlias=1;
  println!("{:?}", a2 + a3);
  // println!("{:?}", a1 == b2);
#+END_SRC

#+RESULTS:
: 1

** Unit Struct
#+BEGIN_SRC rust :exports both
  #[derive(Debug)]
  struct Unit;
  let u = Unit;
  println!("{:?}", u);
#+END_SRC

#+RESULTS:
: Unit

* æšä¸¾
** å®šä¹‰æšä¸¾
#+BEGIN_SRC rust :exports both
  enum Resultish {
      Ok,
      Warning{ code: i32, message: String},
      Err(String)
  }
#+END_SRC

#+RESULTS:

** æšä¸¾å®ä¾‹åŒ–
#+BEGIN_SRC rust :exports both
  #[derive(Debug)]
  enum Resultish {
      Ok,
      Warning{ code: i32, message: String},
      Err(String)
  }

  let ok = Resultish::Ok;
  let err1 = Resultish::Err("bad request".to_string());
  println!("{:?}", ok);
  println!("{:?}", err1);
#+END_SRC

#+RESULTS:
: Ok
: Err("bad request")

** é€’å½’çš„æšä¸¾
#+BEGIN_SRC rust :exports both
  #[derive(Debug)]
  enum List {
      Nil,
      Cons(i32, Box<List>)
  }

  let empty = List::Nil;
  println!("{:?}", empty);

  let head = List::Cons(1, Box::new(empty));
  println!("{:?}", head);
#+END_SRC

#+RESULTS:
: Nil
: Cons(1, Nil)

* æ–¹æ³•
** æ–¹æ³•çš„å®šä¹‰
#+BEGIN_SRC rust :exports both
  #[derive(Debug)]
  struct Point {
      x: i32,
      y: i32,
  }

  impl Point {
      // æ–¹æ³•
      pub fn distance(&self, other: Point) -> f32 {
          let (dx, dy) = (self.x - other.x, self.y - other.y);
          ((dx*dx + dy*dy) as f32).sqrt()
      }
  }

  fn main() {
      let p0 = Point{x:0, y:0};
      let p1 = Point{x:3, y:4};
      let d = p0.distance(p1);
      println!("{:?}", d);
  }
#+END_SRC

#+RESULTS:
: 5.0

** æ–¹æ³•ä¸­ self çš„å…³ç³»
- ~&self~ å€Ÿç”¨ ï¼ˆä¸å¯å˜ï¼‰
- ~&mut self~ å¯å˜å€Ÿç”¨
- ~self~ æ‰€æœ‰æƒè½¬ç§»
#+BEGIN_SRC rust :exports both
  #[derive(Debug)]
  struct Point {
      x: i32,
      y: i32,
  }

  impl Point {
      // æ–¹æ³•ï¼šæ±‚è·ç¦»
      pub fn distance(&self, other: Point) -> f32 {
          let (dx, dy) = (self.x - other.x, self.y - other.y);
          ((dx*dx + dy*dy) as f32).sqrt()
      }

      // å¹³ç§»
      pub fn translate(&mut self, dx: i32, dy: i32) {
          self.x += dx;
          self.y += dy;
      }


      // æŒ‰ y è½´å¯¹ç§° (1, 2) => (-1, 2)
      pub fn mirror_y(self) -> Point {
          Point {x: -self.x, y: self.y }
      }
  }

  fn main() {
      let p0 = Point{x:0, y:0};
      let mut p1 = Point{x:3, y:4};
      p1.translate(3, 1);
      println!("{:?}", p1);
      let p2 = p1.mirror_y();
      println!("{:?}", p2);
      // println!("{:?}", p1);
  }
#+END_SRC

#+RESULTS:
: Point { x: 6, y: 5 }
: Point { x: -6, y: 5 }

* æ¨¡å¼
** æ¨¡å¼åŒ¹é…
- ~0...5~ å·²ç»è¿‡æœŸäº†ï¼Œä¸æ¨èä½¿ç”¨
#+BEGIN_SRC rust :exports both
  let x = 0;
  match x {
      0..=5 => println!("0-5"),
      _ => println!("you still lost the game"),
  }
#+END_SRC

#+RESULTS:
: 0-5
** åŒ¹é…å¼•ç”¨
#+BEGIN_SRC rust :exports both
  let x = 17;
  match x {
      ref r => println!("Of type &i32: {}", r),
  }
#+END_SRC

#+RESULTS:
: Of type &i32: 17

- ~ref mut~ è·å–å˜é‡çš„å¯å˜å¼•ç”¨
#+BEGIN_SRC rust :exports both
  let mut x = 5;
  match x {
      ref r if x == 5 => println!("r = {}", r),
      ref mut r => *r = 5,
  }
  println!("{:?}", x);
#+END_SRC

#+RESULTS:
: r = 5
: 5

** if-let ç»‘å®š
#+BEGIN_SRC rust :exports both
  enum Resultish {
      Ok,
      Warning{ code: i32, message: String},
      Err(String)
  }

  // case1: åªè€ƒè™‘ä¸€ç§æƒ…å†µ
  match make_request() {
      Resultish::Err(_) => println!("Total and utter failure");
      _ => println!("ok");
  }

  // case2: åªè€ƒè™‘ä¸€ç§æƒ…å†µ
  let result = make_request();
  if let Resultish::Err(s) = result {
     println!("Failure: s = {:?}", s);
  } else {
     println!("ok");
  }
#+END_SRC

** while-let ç»‘å®š
#+BEGIN_SRC rust :exports both
  enum Resultish {
      Ok,
      Warning{ code: i32, message: String},
      Err(String)
  }

  let result = make_request();
  while let Resultish::Err(s) = result {
     println!("Failure: s = {:?}", s);
  }
#+END_SRC

** å†…éƒ¨ç»‘å®š inner binding
#+BEGIN_SRC rust :exports both
  #[derive(Debug)]
  enum A {
      None,
      Some(B)
  }

  #[derive(Debug)]
  enum B {
      None,
      Some(i32)
  }

  fn foo(x: A) {
      match x {
          a @ A::None => println!("case I: {:?}", a),
          ref a @ A::Some(B::None) => println!("case II: {:?}", a),
          A::Some(b @ B::Some(_)) => println!("case III: {:?}", b),

          // A::Some(b) => {
          //     match b {
          //         B::None => println!("Case II-1: {:?}", b),
          //         B::Some(_) => println!("Case II-2: {:?}", b),
          //     }
          // },

          _ => println!("default case")
      }
  }

  foo(A::None);
  foo(A::Some(B::None));
  foo(A::Some(B::Some(42)));
#+END_SRC

#+RESULTS:
: case I: None
: Case II-1: None
: Case II-2: Some(42)



: case I: None
: case II: Some(None)
: case III: Some(42)

* ç”Ÿå‘½å‘¨æœŸ
** å¤šå‚æ•°å‡½æ•°çš„ç”Ÿå‘½å‘¨æœŸ
1. å…¥å‚ ~x~ å’Œ ~y~ ä¸è¿”å›å€¼ç”Ÿå‘½å‘¨æœŸéƒ½æ˜¯ ~'a~
#+BEGIN_SRC rust :exports both
  fn borrow_x_or_y<'a>(x: &'a str, y: &'a str) -> &'a str {
      //
  }
#+END_SRC

1. ~p~ çš„ç”Ÿå‘½å‘¨æœŸå’Œè¿”å›å€¼ä¸€æ ·ï¼Œéƒ½æ˜¯ ~'a~
2. ~q~ ç”Ÿå‘½å‘¨æœŸå’Œè¿”å›å€¼æ²¡æœ‰é™åˆ¶ï¼Œæ²¡æœ‰ç»‘å®šå…³ç³»ï¼Œ ~q~ ä¸éœ€è¦å­˜æ´»äºè¿”å›å€¼ä¹‹å
#+BEGIN_SRC rust :exports both
  fn borrow_p<'a, 'b>(p: &'a str, q: &'b str) -> &'a str {
      //
  }
#+END_SRC

** ç”Ÿå‘½å‘¨æœŸå’Œç»“æ„ä½“
#+BEGIN_SRC rust :exports both
  #[derive(Debug)]
  struct Pizza(Vec<i32>); // æŠ«è¨

  #[derive(Debug)]
  struct PizzaSlice<'a> { // æŠ«è¨åˆ‡è¾¹
      pizza: &'a Pizza,
      index: u32,
  }

  let p1 = Pizza(vec![1, 2, 3, 4]);
  println!("{:?}", p1);
  {
      let s1 = PizzaSlice{pizza: &p1, index: 2};
      println!("{:?}", s1);
  }
  // println!("{:?}", s1);

  let s2: PizzaSlice; // æŠ«è¨åˆ‡ç‰‡
  {
      let p2 = Pizza(vec![1, 2, 3, 4]);
      println!("{:?}", p2);
      s2 = PizzaSlice{pizza: &p2, index: 2};
      // println!("{:?}", s2);
  }
  // p2 é”€æ¯äº†, s2 å¹¶æ²¡æœ‰é”€æ¯
  // println!("{:?}", s2);
#+END_SRC

#+RESULTS:
: Pizza([1, 2, 3, 4])
: PizzaSlice { pizza: Pizza([1, 2, 3, 4]), index: 2 }
: Pizza([1, 2, 3, 4])

** ç”Ÿå‘½å‘¨æœŸ outlive é™å®šç¬¦
-  <'b: 'a> è¯´æ˜ 'b outlives 'a
#+BEGIN_SRC rust :exports both
  #[derive(Debug)]
  struct Pizza(Vec<i32>); // æŠ«è¨

  #[derive(Debug)]
  struct PizzaSlice<'a> { // æŠ«è¨åˆ‡è¾¹
      pizza: &'a Pizza,
      index: u32,
  }

  #[derive(Debug)]
  struct PizzaConsumer<'a, 'b: 'a> { // æŠ«è¨æ¶ˆè´¹è€… ã€åœ¨åƒæŠ«è¨ã€‘, 'b: 'a è¯´æ˜ 'b outlives 'a
      slice: PizzaSlice<'a>,  // å½“å‰åƒçš„æŠ«è¨
      pizza: &'b Pizza,      // åŸå§‹çš„æŠ«è¨
  }


  fn get_another_slice(c: &mut PizzaConsumer, index: u32) {
      c.slice = PizzaSlice{pizza: c.pizza, index: index}
  }

  let p = Pizza(vec![1, 2, 3, 4]);
  {
      let s = PizzaSlice{pizza: &p, index: 1};
      // åˆå§‹åŒ–ç¬¬ä¸€ç‰‡ğŸ•
      let mut c = PizzaConsumer{slice: s, pizza: &p};

      // å†åƒä¸€ç‰‡ï¼Œç¬¬äºŒç‰‡ğŸ•
      get_another_slice(&mut c, 2);
  }
#+END_SRC

#+RESULTS:

** ~'static~ ç”Ÿå‘½å‘¨æœŸ
- ~'static~ æŒ‡å®šç¨‹åºè¿è¡Œæ—¶é—´éƒ½ä¸é”€æ¯ã€ä¸€ç›´å­˜åœ¨ã€‘ï¼Œé™æ€çš„ç”Ÿå‘½å‘¨æœŸ
#+BEGIN_SRC rust :exports both
  let s1: &str = "Hello";
  let s2: &'static str = "World";
#+END_SRC

#+RESULTS:

** struct å’Œ enum ä¸­å¼•ç”¨ç±»å‹éƒ½éœ€è¦æ˜¾ç¤ºæŒ‡å®šç”Ÿå‘½å‘¨æœŸ
#+BEGIN_SRC rust :exports both
  struct Foo<'a, 'b> {
      v: &'a Vec<i32>, // ä¼šå›æ”¶
      s: &'b str,      // 'static
  }
#+END_SRC

#+RESULTS:

** impl çš„ç”Ÿå‘½å‘¨æœŸ
#+BEGIN_SRC rust :exports both
  struct Foo<'a, 'b> {
      v: &'a Vec<i32>, // ä¼šå›æ”¶
      s: &'b str,      // 'static
  }

  // å®ç°çš„ä¸Šé¢å‘¨æœŸ
  impl<'a, 'b> Foo<'a, 'b> {
      fn new(v: &'a Vec<i32>, s: &'b str) -> Foo<'a, 'b> {
          Foo {v: v, s: s}
      }
  }
#+END_SRC

#+RESULTS:
