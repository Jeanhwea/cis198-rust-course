#+TITLE: Lecture 1: 所有权和生命周期
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2024-03-24 Sun>
#+STARTUP: overview num indent
#+OPTIONS: ^:nil


* 所有权
** 所有权
#+BEGIN_SRC rust :exports both
  let mut v1 = vec![1, 2, 3];

  // scope
  {
      v1.pop();
      println!("{:?}", v1);
      v1.push(6);
      println!("{:?}", v1);
  } // end of scope

  println!("{:?}", v1);
#+END_SRC

#+RESULTS:
: [1, 2]
: [1, 2, 6]
: [1, 2, 6]

** move 语义
#+BEGIN_SRC rust :exports both
  let x = vec![1, 2, 3];
  // println!("{:?}", x);

  let y = x;
  println!("{:?}", x);
  // println!("{:?}", y);
#+END_SRC

#+RESULTS:
: error: Could not compile `cargonsyXLM`.

** 所有权返回
#+BEGIN_SRC rust :exports both
  fn vector_length(v: Vec<i32>) -> Vec<i32> {
      println!("len = {:?}", v.len());
      v
  }

  fn main() {
      let mut v1 = vec![1, 2, 3];
      v1 = vector_length(v1);
      println!("{:?}", v1);
  }
#+END_SRC

#+RESULTS:
: len = 3
: [1, 2, 3]

** 借用
- 所有: 只能一个所有
- 借用：可以是多个借用
#+BEGIN_SRC rust :exports both
  let v1 = vec![1, 2, 3];

  // let v2 = v1;
  let v2 = &v1; // 发生了借用
  let v3 = &v1; // 发生了借用

  println!("{v2:?}");
  println!("{v3:?}");
  println!("{v1:?}");
#+END_SRC

#+RESULTS:
: [1, 2, 3]
: [1, 2, 3]
: [1, 2, 3]

** 借用后再 move 会报错
#+BEGIN_SRC rust :exports both
  let v1 = vec![1, 2, 3];

  let v2 = &v1; // 发生了借用 v2
  let v3 = v1; // 此时会报错，借用过后的数据区不允许再 move

  println!("{v2:?}");
  println!("{v3:?}");
  println!("{v1:?}");
#+END_SRC

#+RESULTS:
: error: Could not compile `cargoVzbNf8`.

** 包含函数的借用
- 过了作用域会返回借用的数据区
#+BEGIN_SRC rust :exports both
  fn vec_len(v: &Vec<i32>) -> usize {
      v.len()
  }

  let v1 = vec![1, 2, 3, 8];
  println!("{:?}", vec_len(&v1));

  let v2 = v1;
  println!("{v2:?}");
#+END_SRC

#+RESULTS:
: 4
: [1, 2, 3, 8]

** 可变借用
- 过了作用域会返回借用的数据区
- 默认不可变(mutable) => ~mut~
#+BEGIN_SRC rust :exports both
  fn push(v: &mut Vec<i32>, x: i32) {
      v.push(x)
  }

  let mut v1: Vec<i32> = vec![1, 2];
  push(&mut v1, 7);
  println!("{:?}", v1);
#+END_SRC

#+RESULTS:
: [1, 2, 7]

** 可变借用后的变量不可解引用
#+BEGIN_SRC rust :exports both
  fn push2(v: &mut Vec<i32>, x: i32) {
      // error[E0507]: cannot move out of `*v` which is behind a mutable reference
      let v2 = *v; // 这里是错误的

      v2.push(x)
  }

  let mut v1 = vec![1, 2];
  push2(&mut v1, 4);
  println!("{:?}", v1);
#+END_SRC

#+RESULTS:
: error: Could not compile `cargoLOfpQD`.

** 可变借用后自动解引用
#+BEGIN_SRC rust :exports both
  fn vec_len(v: &Vec<i32>) -> usize {
      // let v1 = *v;
      // v1.len()
      v.len()
  }

  let v1 = vec![1, 2, 3, 8, 9];
  println!("{:?}", vec_len(&v1));
#+END_SRC

#+RESULTS:
: 5
